---
title = "K8s primer"
---

This primer is targeted to developers who mainly work on product features but 
may also need to understand the basics of Kubernetes at a practical level,
so that they know how their applications are managed, and, why not, so that
they can actually understand as well the jargon their infrastructure colleagues
use.
If you are already familiarized with building containerized applications, you can
skip directly to step 4.

### 1\. Alright, let's start
We want to deploy a [Go] application using [Kubernetes (K8s)]. This is the application:

*File `main.go`*
```
package main

import (
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	id := rand.Int()

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello world (ID: %d)\n", id)
	})

	fmt.Printf("Serving on http://localhost:7070 (ID: %d)\n", id)
	log.Fatal(http.ListenAndServe(":7070", nil))
}
```

It's a simple HTTP server that listens on port 7070 and responds to requests with 
a "Hello world" followed by a random integer. 

You can run this app locally on your personal machine as follows:

```
$ go run main.go
Serving on http://localhost:7070 (ID: 3628456987918824506)
```

And you can query the server just by doing:

```
$ curl localhost:7070
Hello world (ID: 3628456987918824506)
```

So far so good, I hope.

### 2. K8s only supports containerized applications
We cannot just deploy our Go app by "handing over" the compiled binary to K8s.
K8s only runs application within containers. Let's containerize our Go app; I'll use [Docker] for that:

*File: `Dockerfile`*
```
FROM golang:1.19-alpine3.15 as build
WORKDIR /app
COPY main.go ./
RUN go build -o /app/HelloWorld main.go
EXPOSE 7070

FROM alpine:3.15
USER nobody:nobody
COPY --from=build /app/HelloWorld /HelloWorld

CMD ["/HelloWorld"]
```

This `Dockerfile` contains all the commands needed to build an image that
will contain our application binary. Let's build the image:

```
$ docker build -t YOUR-HANDLE/hello-world-go:1.0.0 .
```

Once our image is built, it's stored in our personal machine: 

```
$ docker image ls                                                
REPOSITORY                     TAG       IMAGE ID       CREATED       SIZE
YOUR-HANDLE/hello-world-go   1.0.0     a2fe58fdd36f   2 seconds ago    11.6MB
```

We can now run our containerized Go app by doing:
```
$ docker run --rm -p 7070:7070 YOUR-HANDLE/hello-world-go:1.0.0

Serving on http://localhost:7070 (ID: 3888774625775762015)
```

We can query our containerized Go app using `curl localhost:7070` just like before.

### 3. K8s cannot access our personal machine to retrieve the Go app image

The image we just built is stored in our personal machine, but K8s doesn't 
about what's in our machine. The standard approach is to make our container 
image available via a container registry. I'll use [Docker Hub] to publish (for free) 
my Go app image:

```
$ docker login -u YOUR-HANDLE
$ docker push YOUR-HANDLE/hello-world-go:1.0.0
```

(You'll need to input your [personal access token] to login into Docker Hub.)

Now our Go app image is publicly available via Docker Hub.

### 4. We need some kind of machine/server/node where K8s can run

While we can use a fully managed K8s service like [GKE] and [EKS],
I'll use [minikube] to run K8s locally on my machine.
TODO----------->
K8s has the notion of a [cluster]. A cluster is a set of nodes. A node can be
a physical or a virtual machine. Let's create a cluster of 3 (virtual) nodes
using [minikube]:

```
$ minikube start --nodes 3 -p minikube-lab
```

Nice. We got 3 nodes. We could deploy our Go application on them. Let's use
[kubectl] to ask K8s about the status of the cluster:

```
$ kubectl get nodes

NAME               STATUS   ROLES           AGE    VERSION
minikube-lab       Ready    control-plane   2d1h   v1.25.2
minikube-lab-m02   Ready    <none>          3h5m   v1.25.2
minikube-lab-m03   Ready    <none>          3h4m   v1.25.2
```

K8s is telling us that we have 3 nodes, each of them with a unique name and
ready for whatever we need them. One of the nodes works as the [control plane]
of our cluster (i.e., it's on charge of managing our cluster), while the other
2 nodes are worker nodes (i.e., nodes on which we can deploy applications).

### 3\. 


[Go]: https://go.dev/
[Docker]: https://www.docker.com/
[Kubernetes (K8s)]: https://kubernetes.io/
[Docker Hub]: https://hub.docker.com/
[personal access token]: https://www.docker.com/blog/docker-hub-new-personal-access-tokens/
[GKE]: https://cloud.google.com/kubernetes-engine
[EKS]: https://aws.amazon.com/eks/
[cluster]: https://kubernetes.io/docs/concepts/overview/components/
[minikube]: https://minikube.sigs.k8s.io/docs/start/
[kubectl]: https://minikube.sigs.k8s.io/docs/handbook/kubectl/
[control plane]: https://kubernetes.io/docs/concepts/overview/components/#control-plane-components